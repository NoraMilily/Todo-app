# Реактивные обновления - Как работает автоматическое обновление интерфейса

## Что такое реактивные обновления?

Реактивные обновления - это способность интерфейса автоматически изменяться при изменении данных, без необходимости перезагружать страницу вручную.

**Простыми словами:** когда вы создаете задачу, она сразу появляется в списке без перезагрузки страницы.

## Почему это важно?

Без реактивных обновлений пользователю пришлось бы:
- Создать задачу
- Вручную обновить страницу (F5)
- Увидеть новую задачу

С реактивными обновлениями:
- Создать задачу
- Задача сразу появляется в списке

## Как это работает в проекте?

### Механизм обновления

В этом проекте используется комбинация:
1. **Server Actions** - выполняют операции на сервере
2. **revalidatePath** - обновляет кэш страницы
3. **React состояние** - автоматически перерисовывает компонент

### Пример 1: Создание задачи

**Что происходит пошагово:**

**Шаг 1: Пользователь заполняет форму**

```typescript
// Пользователь вводит данные в форму
<form action={addTodoFormAction}>
  <input name="text" value="Купить молоко" />
  <input name="dueDate" value="2026-01-30" />
  <select name="priority" value="MEDIUM" />
  <button type="submit">Добавить</button>
</form>
```

**Шаг 2: Отправка данных**

Когда пользователь нажимает "Добавить", форма отправляет данные на сервер через Server Action.

**Шаг 3: Обработка на сервере**

```typescript
// src/app/actions/todos.ts
export async function addTodoAction(...) {
  // Сохранение в базу данных
  await prisma.todo.create({ data: { ... } });
  
  // ВАЖНО: Обновление кэша страницы
  revalidatePath(`/${locale}`);
  
  return { ok: true };
}
```

**Что делает `revalidatePath`?**

Эта функция говорит Next.js: "Данные на этой странице изменились, нужно их обновить".

**Шаг 4: Автоматическое обновление**

Next.js:
1. Замечает, что кэш страницы устарел
2. Автоматически перезапрашивает данные с сервера
3. Обновляет компонент с новыми данными

**Шаг 5: Отображение новой задачи**

React видит, что данные изменились, и автоматически перерисовывает компонент. Новая задача появляется в списке.

### Пример 2: Редактирование задачи

**Шаг 1: Пользователь нажимает "Редактировать"**

```typescript
// В компоненте TodoApp.tsx
onClick={() => {
  setEditingId(todo.id); // Устанавливаем ID редактируемой задачи
  setEditingText(todo.text); // Загружаем текущий текст
  setEditingDueDate(...); // Загружаем текущую дату
}}
```

**Шаг 2: Отображение формы редактирования**

React видит изменение состояния `editingId` и показывает форму редактирования вместо текста задачи.

**Шаг 3: Сохранение изменений**

```typescript
// Пользователь изменяет данные и нажимает "Сохранить"
await updateTodoAction(todo.id, editingText, editingDueDate, editingPriority);
```

**Шаг 4: Обновление на сервере**

```typescript
// src/app/actions/todos.ts
await prisma.todo.updateMany({
  where: { id, userId },
  data: { text, dueDate, priority },
});

revalidatePath(`/${locale}`); // Обновляем кэш
```

**Шаг 5: Закрытие формы редактирования**

```typescript
setEditingId(null); // Убираем режим редактирования
setEditingText(""); // Очищаем поля
```

**Шаг 6: Отображение обновленной задачи**

Next.js обновляет данные, React перерисовывает компонент, и пользователь видит обновленную задачу.

### Пример 3: Удаление задачи

**Шаг 1: Пользователь нажимает "Удалить"**

```typescript
onClick={() => {
  startTransition(async () => {
    await deleteTodoAction(todo.id);
  });
}}
```

**Шаг 2: Удаление из базы данных**

```typescript
// src/app/actions/todos.ts
await prisma.todo.deleteMany({
  where: { id, userId },
});

revalidatePath(`/${locale}`);
```

**Шаг 3: Автоматическое исчезновение задачи**

После обновления кэша задача исчезает из списка автоматически, так как она больше не существует в базе данных.

### Пример 4: Изменение статуса задачи (выполнено/не выполнено)

**Шаг 1: Пользователь кликает на чекбокс**

```typescript
<input
  type="checkbox"
  checked={todo.completed}
  onChange={(e) => {
    await toggleTodoAction(todo.id, e.target.checked);
  }}
/>
```

**Шаг 2: Обновление статуса**

```typescript
// src/app/actions/todos.ts
await prisma.todo.updateMany({
  where: { id, userId },
  data: { completed: true }, // или false
});

revalidatePath(`/${locale}`);
```

**Шаг 3: Визуальное изменение**

После обновления задача автоматически:
- Перечеркивается (если выполнена)
- Меняет цвет
- Перемещается в соответствующий раздел при фильтрации

## Управление состоянием в React

### Что такое состояние?

Состояние - это данные компонента, которые могут изменяться и влияют на отображение.

### Типы состояния в проекте

**1. Состояние списка задач**

```typescript
// Загружается с сервера при открытии страницы
const todos = [
  { id: "1", text: "Задача 1", completed: false },
  { id: "2", text: "Задача 2", completed: true },
];
```

Когда задача создается, обновляется или удаляется, этот список автоматически обновляется.

**2. Состояние редактирования**

```typescript
const [editingId, setEditingId] = useState<string | null>(null);
```

Когда `editingId` не null, показывается форма редактирования для задачи с этим ID.

**3. Состояние фильтра**

```typescript
const [filter, setFilter] = useState<"all" | "active" | "completed">("all");
```

Определяет, какие задачи показывать: все, только активные или только выполненные.

**4. Состояние ошибок**

```typescript
const [error, setError] = useState<string | null>(null);
```

Хранит сообщение об ошибке, если что-то пошло не так.

### Как React отслеживает изменения?

React использует систему реактивности:

1. Когда состояние изменяется через `setState`
2. React сравнивает старое и новое состояние
3. Если есть различия, React перерисовывает компонент
4. Пользователь видит обновленный интерфейс

**Пример:**

```typescript
// Начальное состояние
const [count, setCount] = useState(0);

// При изменении
setCount(1); // React автоматически перерисовывает компонент
```

## Анимации при обновлении

В проекте используется библиотека `framer-motion` для плавных анимаций.

**Когда задача добавляется:**

```typescript
<motion.div
  initial={{ opacity: 0, scale: 0.9, y: -10 }} // Начальное состояние
  animate={{ opacity: 1, scale: 1, y: 0 }}     // Конечное состояние
  exit={{ opacity: 0, scale: 0.8, y: -10 }}    // При удалении
>
  {/* Задача */}
</motion.div>
```

Это создает плавное появление и исчезновение задач.

## Оптимистичные обновления

**Что это?**

Оптимистичное обновление - это когда интерфейс обновляется сразу, до получения подтверждения от сервера.

**Пример в проекте:**

Когда пользователь кликает чекбокс "Выполнено":
1. Интерфейс сразу меняется (задача перечеркивается)
2. Запрос отправляется на сервер
3. Если запрос успешен - все хорошо
4. Если запрос провалился - интерфейс откатывается назад

Это создает ощущение мгновенного отклика приложения.

## Резюме

Реактивные обновления работают так:

1. **Действие пользователя** → изменение данных
2. **Server Action** → сохранение в базу данных
3. **revalidatePath** → обновление кэша
4. **Next.js** → автоматическая перезагрузка данных
5. **React** → автоматическая перерисовка компонента
6. **Пользователь** → видит обновленный интерфейс

Все это происходит автоматически, без необходимости перезагружать страницу вручную.
