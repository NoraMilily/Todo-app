# Frontend и Backend - Объяснение архитектуры

## Что такое Frontend и Backend?

В веб-приложениях код разделен на две части:

- **Frontend (клиентская часть)** - то, что видит и с чем взаимодействует пользователь в браузере
- **Backend (серверная часть)** - код, который выполняется на сервере и обрабатывает запросы

В этом проекте обе части написаны на JavaScript/TypeScript, но выполняются в разных местах.

## Frontend в этом проекте

### Что делает Frontend?

Frontend отвечает за:
- Отображение интерфейса пользователя
- Обработку действий пользователя (клики, ввод текста)
- Отправку запросов на сервер
- Обновление интерфейса после получения ответа от сервера

### Структура Frontend

#### Папка `src/components/`

Здесь находятся React компоненты - переиспользуемые части интерфейса:

- **TodoApp.tsx** - главный компонент списка задач
  - Отображает список задач
  - Содержит форму создания новой задачи
  - Обрабатывает редактирование и удаление задач

- **LoginForm.tsx** - форма входа в систему
  - Поля для email/username и пароля
  - Отправляет данные на сервер для проверки

- **RegisterForm.tsx** - форма регистрации
  - Поля для создания нового аккаунта
  - Валидация данных на клиенте

- **ForgotPasswordForm.tsx** - форма восстановления пароля
  - Двухшаговый процесс восстановления

- **ProfileForm.tsx** - форма редактирования профиля
  - Изменение имени и аватара

#### Как Frontend общается с Backend?

В этом проекте используется подход **Server Actions** от Next.js.

**Обычный способ (через API):**
```
Frontend → HTTP запрос → Backend API → База данных
```

**Server Actions (используется в проекте):**
```
Frontend → Вызов функции → Backend функция → База данных
```

Server Actions - это функции, которые выполняются на сервере, но вызываются из клиентского кода как обычные функции.

**Пример из кода:**

В компоненте `TodoApp.tsx`:
```typescript
import { addTodoAction } from "@/app/actions/todos";

// Форма вызывает server action напрямую
<form action={addTodoFormAction}>
  <input name="text" />
  <input name="dueDate" type="date" />
  <button type="submit">Добавить</button>
</form>
```

Когда пользователь нажимает кнопку:
1. Форма собирает данные
2. Next.js автоматически отправляет данные на сервер
3. Выполняется функция `addTodoAction` на сервере
4. Сервер сохраняет данные в базу данных
5. Интерфейс автоматически обновляется

### Управление состоянием

**Что такое состояние?**

Состояние - это данные, которые могут изменяться и влияют на отображение интерфейса.

**Примеры состояния в проекте:**

1. **Список задач** - загружается с сервера и отображается
2. **Режим редактирования** - какая задача сейчас редактируется
3. **Фильтр задач** - показывать все, активные или выполненные
4. **Ошибки** - сообщения об ошибках для пользователя

**Как управляется состояние:**

В React используется хук `useState`:

```typescript
const [todos, setTodos] = useState([]); // Список задач
const [editingId, setEditingId] = useState(null); // ID редактируемой задачи
const [error, setError] = useState(null); // Сообщение об ошибке
```

Когда состояние изменяется, React автоматически перерисовывает компонент.

## Backend в этом проекте

### Что делает Backend?

Backend отвечает за:
- Проверку данных от пользователя
- Работу с базой данных
- Аутентификацию пользователей
- Защиту данных от несанкционированного доступа

### Структура Backend

#### Папка `src/app/actions/`

Здесь находятся Server Actions - функции, выполняющиеся на сервере:

- **todos.ts** - действия для работы с задачами
  - `addTodoAction` - создание новой задачи
  - `updateTodoAction` - обновление задачи
  - `deleteTodoAction` - удаление задачи
  - `toggleTodoAction` - изменение статуса задачи

- **auth.ts** - действия для аутентификации
  - `registerAction` - регистрация нового пользователя
  - `findUserForPasswordReset` - поиск пользователя для восстановления пароля
  - `resetPasswordAction` - сброс пароля

- **profile.ts** - действия для профиля
  - `updateDisplayNameAction` - обновление имени и аватара

**Важно:** Все файлы в `actions/` начинаются с `"use server"` - это указывает Next.js, что код должен выполняться на сервере.

#### Как работает Server Action?

**Пример: создание задачи**

```typescript
// src/app/actions/todos.ts
"use server";

export async function addTodoAction(
  _prev: AddTodoState,
  formData: FormData,
): Promise<AddTodoState> {
  // 1. Проверка авторизации
  const userId = await requireUserId();
  
  // 2. Получение данных из формы
  const text = String(formData.get("text") ?? "");
  const dueDate = String(formData.get("dueDate") ?? "");
  const priority = String(formData.get("priority") ?? "MEDIUM");
  
  // 3. Валидация данных
  // ... проверка данных ...
  
  // 4. Сохранение в базу данных
  await prisma.todo.create({
    data: { text, dueDate, priority, userId },
  });
  
  // 5. Обновление кэша страницы
  revalidatePath(`/${locale}`);
  
  // 6. Возврат результата
  return { ok: true };
}
```

### Работа с базой данных

#### Что такое Prisma?

Prisma - это инструмент (ORM), который позволяет работать с базой данных, используя код на TypeScript вместо SQL.

**Без Prisma (чистый SQL):**
```sql
INSERT INTO "Todo" (text, "dueDate", priority, "userId")
VALUES ('Купить молоко', '2026-01-30', 'MEDIUM', 'user123');
```

**С Prisma:**
```typescript
await prisma.todo.create({
  data: {
    text: "Купить молоко",
    dueDate: new Date("2026-01-30"),
    priority: "MEDIUM",
    userId: "user123",
  },
});
```

**Преимущества Prisma:**
- Автоматическая проверка типов
- Безопасность от SQL-инъекций
- Легко читаемый код
- Автоматическая генерация типов TypeScript

## Как данные движутся через систему

### Пример: Создание новой задачи

**Шаг 1: Пользователь заполняет форму**

Пользователь вводит:
- Текст задачи: "Купить молоко"
- Срок выполнения: 30 января 2026
- Приоритет: Средняя

**Шаг 2: Отправка формы**

Когда пользователь нажимает "Добавить":
```typescript
// Frontend: TodoApp.tsx
<form action={addTodoFormAction}>
  // Next.js автоматически собирает данные формы
</form>
```

**Шаг 3: Вызов Server Action**

Next.js отправляет данные на сервер и вызывает:
```typescript
// Backend: src/app/actions/todos.ts
addTodoAction(previousState, formData)
```

**Шаг 4: Проверка авторизации**

```typescript
const userId = await requireUserId();
// Проверяет, что пользователь вошел в систему
// Если нет - выбрасывает ошибку
```

**Шаг 5: Валидация данных**

```typescript
// Проверка, что текст не пустой
// Проверка формата даты
// Проверка приоритета
```

**Шаг 6: Сохранение в базу данных**

```typescript
await prisma.todo.create({
  data: {
    text: "Купить молоко",
    dueDate: new Date("2026-01-30"),
    priority: "MEDIUM",
    userId: userId,
  },
});
```

Prisma преобразует это в SQL запрос и выполняет его в PostgreSQL.

**Шаг 7: Обновление интерфейса**

```typescript
revalidatePath(`/${locale}`);
// Говорит Next.js обновить страницу
```

**Шаг 8: Отображение новой задачи**

Next.js автоматически перезагружает данные и показывает новую задачу в списке.

## Аутентификация

### Как работает вход в систему?

**Шаг 1: Пользователь вводит данные**

В форме входа пользователь вводит:
- Email или username
- Пароль

**Шаг 2: Отправка на сервер**

Данные отправляются в NextAuth через Server Action.

**Шаг 3: Поиск пользователя**

```typescript
// src/lib/auth.ts
const user = await prisma.user.findFirst({
  where: {
    OR: [
      { email: identifier.toLowerCase() },
      { username: identifier },
    ],
  },
});
```

**Шаг 4: Проверка пароля**

```typescript
const ok = await verifyPassword(password, user.passwordHash);
// Сравнивает введенный пароль с хешем в базе данных
```

**Шаг 5: Создание сессии**

Если пароль правильный, создается JWT токен, который хранится в браузере.

**Шаг 6: Защита маршрутов**

Middleware проверяет наличие токена перед доступом к защищенным страницам:

```typescript
// src/middleware.ts
if (!req.auth) {
  return NextResponse.redirect(new URL(`/${locale}/auth/login`, req.url));
}
```

## Защита данных

### Как обеспечивается безопасность?

1. **Пароли никогда не хранятся в открытом виде**
   - Используется хеширование с bcrypt
   - Даже администратор базы данных не может увидеть пароли

2. **Каждый пользователь видит только свои задачи**
   - Все запросы к базе данных фильтруются по `userId`
   - Невозможно получить доступ к чужим данным

3. **Валидация на клиенте и сервере**
   - Клиентская валидация для удобства пользователя
   - Серверная валидация для безопасности

4. **Защищенные маршруты**
   - Middleware проверяет авторизацию перед доступом к страницам
   - Неавторизованные пользователи перенаправляются на страницу входа

## Резюме

- **Frontend** - интерфейс, который видит пользователь
- **Backend** - логика, которая выполняется на сервере
- **Server Actions** - способ связи между frontend и backend
- **Prisma** - инструмент для работы с базой данных
- **NextAuth** - система аутентификации
- **Middleware** - защита маршрутов

Все эти части работают вместе, чтобы создать безопасное и функциональное приложение.
